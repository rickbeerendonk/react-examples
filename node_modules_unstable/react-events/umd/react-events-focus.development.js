/** @license React vundefined
 * react-events-focus.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('react')) :
	typeof define === 'function' && define.amd ? define(['react'], factory) :
	(global.ReactEventsFocus = factory(global.React));
}(this, (function (React) { 'use strict';

var DiscreteEvent = 0;

var isMac = typeof window !== 'undefined' && window.navigator != null ? /^Mac/.test(window.navigator.platform) : false;

var targetEventTypes = [{ name: 'focus', passive: true }, { name: 'blur', passive: true }];

var rootEventTypes = ['keydown', 'keyup', 'pointermove', 'pointerdown', 'pointerup'];

// If PointerEvents is not supported (e.g., Safari), also listen to touch and mouse events.
if (typeof window !== 'undefined' && window.PointerEvent === undefined) {
  rootEventTypes.push('mousemove', 'mousedown', 'mouseup', 'touchmove', 'touchstart', 'touchend');
}

function createFocusEvent(context, type, target, pointerType) {
  return {
    target: target,
    type: type,
    pointerType: pointerType,
    timeStamp: context.getTimeStamp()
  };
}

function dispatchFocusInEvents(context, props, state) {
  var pointerType = state.pointerType;
  var target = state.focusTarget;
  if (props.onFocus) {
    var syntheticEvent = createFocusEvent(context, 'focus', target, pointerType);
    context.dispatchEvent(syntheticEvent, props.onFocus, DiscreteEvent);
  }
  if (props.onFocusChange) {
    var listener = function () {
      props.onFocusChange(true);
    };
    var _syntheticEvent = createFocusEvent(context, 'focuschange', target, pointerType);
    context.dispatchEvent(_syntheticEvent, listener, DiscreteEvent);
  }
  if (props.onFocusVisibleChange && state.isLocalFocusVisible) {
    var _listener = function () {
      props.onFocusVisibleChange(true);
    };
    var _syntheticEvent2 = createFocusEvent(context, 'focusvisiblechange', target, pointerType);
    context.dispatchEvent(_syntheticEvent2, _listener, DiscreteEvent);
  }
}

function dispatchFocusOutEvents(context, props, state) {
  var pointerType = state.pointerType;
  var target = state.focusTarget;
  if (props.onBlur) {
    var syntheticEvent = createFocusEvent(context, 'blur', target, pointerType);
    context.dispatchEvent(syntheticEvent, props.onBlur, DiscreteEvent);
  }
  if (props.onFocusChange) {
    var listener = function () {
      props.onFocusChange(false);
    };
    var _syntheticEvent3 = createFocusEvent(context, 'focuschange', target, pointerType);
    context.dispatchEvent(_syntheticEvent3, listener, DiscreteEvent);
  }
  dispatchFocusVisibleOutEvent(context, props, state);
}

function dispatchFocusVisibleOutEvent(context, props, state) {
  var pointerType = state.pointerType;
  var target = state.focusTarget;
  if (props.onFocusVisibleChange && state.isLocalFocusVisible) {
    var listener = function () {
      props.onFocusVisibleChange(false);
    };
    var syntheticEvent = createFocusEvent(context, 'focusvisiblechange', target, pointerType);
    context.dispatchEvent(syntheticEvent, listener, DiscreteEvent);
    state.isLocalFocusVisible = false;
  }
}

function unmountResponder(context, props, state) {
  if (state.isFocused) {
    dispatchFocusOutEvents(context, props, state);
  }
}

function handleRootPointerEvent(event, context, props, state) {
  var type = event.type,
      target = event.target;
  // Ignore a Safari quirks where 'mousemove' is dispatched on the 'html'
  // element when the window blurs.

  if (type === 'mousemove' && target.nodeName === 'HTML') {
    return;
  }

  isGlobalFocusVisible = false;

  // Focus should stop being visible if a pointer is used on the element
  // after it was focused using a keyboard.
  if (state.focusTarget === context.getEventCurrentTarget(event) && (type === 'mousedown' || type === 'touchstart' || type === 'pointerdown')) {
    dispatchFocusVisibleOutEvent(context, props, state);
  }
}

var isGlobalFocusVisible = true;

var FocusResponder = {
  displayName: 'Focus',
  targetEventTypes: targetEventTypes,
  rootEventTypes: rootEventTypes,
  createInitialState: function () {
    return {
      focusTarget: null,
      isFocused: false,
      isLocalFocusVisible: false,
      pointerType: ''
    };
  },

  allowMultipleHostChildren: false,
  allowEventHooks: true,
  onEvent: function (event, context, props, state) {
    var type = event.type,
        target = event.target;


    if (props.disabled) {
      if (state.isFocused) {
        dispatchFocusOutEvents(context, props, state);
        state.isFocused = false;
        state.focusTarget = null;
      }
      return;
    }

    switch (type) {
      case 'focus':
        {
          if (!state.isFocused) {
            // Limit focus events to the direct child of the event component.
            // Browser focus is not expected to bubble.
            state.focusTarget = context.getEventCurrentTarget(event);
            if (state.focusTarget === target) {
              state.isFocused = true;
              state.isLocalFocusVisible = isGlobalFocusVisible;
              dispatchFocusInEvents(context, props, state);
            }
          }
          break;
        }
      case 'blur':
        {
          if (state.isFocused) {
            dispatchFocusOutEvents(context, props, state);
            state.isFocused = false;
            state.focusTarget = null;
          }
          break;
        }
    }
  },
  onRootEvent: function (event, context, props, state) {
    var type = event.type;


    switch (type) {
      case 'mousemove':
      case 'mousedown':
      case 'mouseup':
        {
          state.pointerType = 'mouse';
          handleRootPointerEvent(event, context, props, state);
          break;
        }
      case 'pointermove':
      case 'pointerdown':
      case 'pointerup':
        {
          // $FlowFixMe: Flow doesn't know about PointerEvents
          var nativeEvent = event.nativeEvent;
          state.pointerType = nativeEvent.pointerType;
          handleRootPointerEvent(event, context, props, state);
          break;
        }
      case 'touchmove':
      case 'touchstart':
      case 'touchend':
        {
          state.pointerType = 'touch';
          handleRootPointerEvent(event, context, props, state);
          break;
        }

      case 'keydown':
      case 'keyup':
        {
          var _nativeEvent = event.nativeEvent;
          if (_nativeEvent.key === 'Tab' && !(_nativeEvent.metaKey || !isMac && _nativeEvent.altKey || _nativeEvent.ctrlKey)) {
            state.pointerType = 'keyboard';
            isGlobalFocusVisible = true;
          }
          break;
        }
    }
  },
  onUnmount: function (context, props, state) {
    unmountResponder(context, props, state);
  },
  onOwnershipChange: function (context, props, state) {
    unmountResponder(context, props, state);
  }
};

var Focus = React.unstable_createEvent(FocusResponder);

function useFocus(props) {
  React.unstable_useEvent(Focus, props);
}

var Focus$1 = Object.freeze({
	Focus: Focus,
	useFocus: useFocus
});

var focus = Focus$1;

return focus;

})));
